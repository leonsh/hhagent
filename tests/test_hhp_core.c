#include <string.h>
#include <unity.h>
#include <hhp_core.c>

uint8_t udata[512];
uint8_t udata_pos = 0;
struct hh_prot tst_prot;
uint8_t cb_flag;
struct hh_dev_info dev_info;
enum hh_join_stage join_stage;

void mock_join_req_cb(struct hh_dev_info *info, enum hh_join_stage stage)
{
	cb_flag = 0xFF;
	memcpy(&dev_info, info, sizeof(struct hh_dev_info));
	join_stage = stage;
}

void setUp(void)
{
	memset(udata, 0x00, sizeof(udata));
	memset(&tst_prot, 0, sizeof(struct hh_prot));
	memset(&dev_info, 0, sizeof(struct hh_dev_info));
	udata_pos = 0;
}
void tearDown(void)
{

}
void mock_usart_send(uint8_t data)
{
	udata[udata_pos++] = data;
}

/* Verify CRC16 function */
void test_crc16_data2_should_ok(void)
{
    union {
        unsigned short i;
        uint8_t c[2];
    } crc ;
	uint8_t data[] = {
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
		0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
	};
	crc.i = crc16_data2(data, sizeof(data), 0);
	TEST_ASSERT_EQUAL(0xFF, crc.c[0]);
    TEST_ASSERT_EQUAL(0xD2, crc.c[1]);

}

/* Send Networking Package Test, verify send data crc16 */
void test_hh_switch_status_should_send_data(void)
{
	hh_usart_reg_write_func(mock_usart_send);
	TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_switch_status(HH_CONN_CTRL));
	TEST_ASSERT_EQUAL(0xF0, udata[0]);
	TEST_ASSERT_EQUAL(0xA5, udata[1]);
}

/* Send Data Test with all 0x11, and verify crc16 */
void test_hh_send_data(void)
{
	memset(&tst_prot, 0x11, sizeof(struct hh_prot));
	hh_usart_reg_write_func(mock_usart_send);
	TEST_ASSERT_EQUAL(64, hh_send_data(&tst_prot));
	TEST_ASSERT_EQUAL(0xF0, udata[0]);
	TEST_ASSERT_EQUAL(0xA5, udata[1]);
	TEST_ASSERT_EQUAL(0xCD, udata[62]);
	TEST_ASSERT_EQUAL(0xC4, udata[63]);
}

/* Receive data test, verify crc calc and state change */
void test_hh_receive_data(void)
{
	int32_t i = 0;
	TEST_ASSERT_EQUAL(HH_CONN_ONLINE, status);
	uint8_t sim_data[64] = {
		0xF0, 0xA5, 0xC0, 0x00, 0x01, 0x01, 0x01, 0x02,
		0x23, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6C, 0xAC
	};
	for (i = 0; i < 64; i++) {
		hh_usart_read(sim_data[i]);
	}
	TEST_ASSERT_EQUAL(HH_CONN_CTRL, status);

	/* incorrect data should not be process */
	sim_data[63] = 0x00;
	status = HH_CONN_ONLINE;
	for (i = 0; i < 64; i++) {
		hh_usart_read(sim_data[i]);
	}
	TEST_ASSERT_EQUAL(HH_CONN_ONLINE, status);
}

/* New device join request test */
void test_hh_device_join(void)
{
	int32_t i = 0;

	cb_flag = 0x00;
	hh_reg_join_cb_func(mock_join_req_cb);

	uint8_t sim_data[64] = {
		0xF0, 0xA5, 0xC0, 0x00, 0x01, 0x01, 0x01, 0x17,
		0x24, 0x00, 0x00, 0x01, 0x00, 0xAA, 0xBB, 0x77,
		0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00, 0xE3,
		0xF3, 0xE4, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD9, 0xD2
	};
	for (i = 0; i < 64; i++) {
		hh_usart_read(sim_data[i]);
	}

	TEST_ASSERT_EQUAL(0xFF, cb_flag);
	TEST_ASSERT_EQUAL_UINT8_ARRAY(dev_info.mac, sim_data + 0x0F, 8);
	/* First Join Stage should finished */
	TEST_ASSERT_EQUAL(HH_JOIN_REQUEST, join_stage);

	hh_join_ack(&dev_info, true);
	TEST_ASSERT_EQUAL(0x24, udata[8]);
	TEST_ASSERT_EQUAL(0x01, udata[9]);
	TEST_ASSERT_EQUAL(0xAA, udata[10]);
	TEST_ASSERT_EQUAL(0xBB, udata[11]);

    udata_pos = 0;
	hh_join_ack(&dev_info, false);
	TEST_ASSERT_EQUAL(0x24, udata[8]);
	TEST_ASSERT_EQUAL(0x00, udata[9]);
	TEST_ASSERT_EQUAL(0xAA, udata[10]);
	TEST_ASSERT_EQUAL(0xBB, udata[11]);

	uint8_t ack_sim_data[64] = {
		0xF0, 0xA5, 0xC0, 0x00, 0x01, 0x01, 0x01, 0x04,
		0x24, 0x66, 0xAA, 0xBB, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x26
	};
	for (i = 0; i < 64; i++) {
		hh_usart_read(ack_sim_data[i]);
	}
	/* Second(last) Join Stage should finished after receive 2466 */
	TEST_ASSERT_EQUAL(HH_JOIN_FINISHED, join_stage);
}

void test_recevice_v2_trap(void)
{
    enum hh_msg_type t;
    int32_t i = 0;
    struct hh_oid_entry entry;

	uint8_t sim_data[64] = {
		0xF0, 0xA5, 0x00, 0x02, 0x00, 0x01, 0x01, 0x33,
		0x41, 0xBE, 0xB3, 0x2F, 0x30, 0x2D, 0x02, 0x01,
		0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6C, 0x69, /* publi         */
		0x63, 0xA7, 0x20, 0x02, 0x01, 0x00, 0x02, 0x01, /* c + trap      */
		0x00, 0x02, 0x01, 0x00, 0x30, 0x15, 0x30, 0x13, /* 1.            */
		0x06, 0x0B, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, /* 3.6.1.4.1.    */
		0xC3, 0x7B, 0x01, 0x64, 0x02, 0x02, 0x04, 0x00, /* 41467.1.100.2 */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3, 0xA0
	};
	for (i = 0; i < 64; i++) {
		t = hh_usart_read(sim_data[i]);
		if (i < 63) {
			TEST_ASSERT_EQUAL(HH_MSG_DATA, t);
		} else {
			TEST_ASSERT_EQUAL(HH_MSG_TRAP, t);
		}
	}
	TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_msg_get_next_item(&entry));
    TEST_ASSERT_EQUAL(HH_OID_ION_STATUS, entry.oid_name);
    TEST_ASSERT_EQUAL(HH_OID_INTEGER, entry.oid_type);
    TEST_ASSERT_EQUAL(0, entry.index);
    TEST_ASSERT_EQUAL(0, entry.val.int_val);
	TEST_ASSERT_EQUAL(HHP_NO_RESOURCE, hh_msg_get_next_item(&entry));
	/* Process Trap Message */
}

void test_recv_trap_with_multi_entries(void)
{
    enum hh_msg_type t;
    int32_t i = 0;
    struct hh_oid_entry entry;

    uint8_t sim_data[128] = {
		0xF0, 0xA5, 0x00, 0x02, 0x00, 0x02, 0x01, 0x36,
		0x41, 0xBE, 0xB3, 0x32, 0x30, 0x42, 0x02, 0x01,
		0x01, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6C, 0x69, /* publi         */
		0x63, 0xA7, 0x35, 0x02, 0x01, 0x00, 0x02, 0x01, /* c + trap      */
		0x00, 0x02, 0x01, 0x00, 0x30, 0x2A, 0x30, 0x13, /* 1.            */
		0x06, 0x0B, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, /* 3.6.1.4.1.    */
		0xC3, 0x7B, 0x01, 0x64, 0x02, 0x02, 0x04, 0x00, /* 41467.1.100.2 */
		0x00, 0x00, 0x00, 0x30, 0x13, 0x06, 0x7A, 0x39,
		0xF0, 0xA5, 0x00, 0x02, 0x00, 0x02, 0x02, 0x16,
		0x41, 0xBE, 0xB3, 0x12, 0x0B, 0x2B, 0x06, 0x01,
        0x04, 0x01, 0x82, 0xC3, 0x7B, 0x01, 0x64, 0x03, /* 41467.1.100.3 */
        0x02, 0x04, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, /* 0x12          */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA6, 0xAE
	};
    for (i = 0; i < 64; i++) {
		t = hh_usart_read(sim_data[i]);
		if (i < 63) {
			TEST_ASSERT_EQUAL(HH_MSG_DATA, t);
		} else {
			TEST_ASSERT_EQUAL(HH_MSG_DATA, t);
		}
	}
    for (i = 64; i < 128; i++) {
		t = hh_usart_read(sim_data[i]);
		if (i < 127) {
			TEST_ASSERT_EQUAL(HH_MSG_DATA, t);
		} else {
			TEST_ASSERT_EQUAL(HH_MSG_TRAP, t);
		}
	}
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_msg_get_next_item(&entry));
    TEST_ASSERT_EQUAL(HH_OID_ION_STATUS, entry.oid_name);
    TEST_ASSERT_EQUAL(HH_OID_INTEGER, entry.oid_type);
    TEST_ASSERT_EQUAL(0, entry.index);
    TEST_ASSERT_EQUAL(0, entry.val.int_val);

    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_msg_get_next_item(&entry));
    TEST_ASSERT_EQUAL(HH_OID_ION_ELEC, entry.oid_name);
    TEST_ASSERT_EQUAL(HH_OID_INTEGER, entry.oid_type);
    TEST_ASSERT_EQUAL(0, entry.index);
    TEST_ASSERT_EQUAL(0x12, entry.val.int_val);

	TEST_ASSERT_EQUAL(HHP_NO_RESOURCE, hh_msg_get_next_item(&entry));
	/* Process Trap Message */
}

void test_build_snmp_setpdu(void)
{
    struct hh_oid_entry entry[2];

    entry[0].index = 0;
    entry[0].oid_name = HH_OID_ION;
    entry[0].oid_type = HH_OID_INTEGER;
    entry[0].val.int_val = 1;

    entry[1].index = 0;
    entry[1].oid_name = HH_OID_ION_ELEC;
    entry[1].oid_type = HH_OID_INTEGER;
    entry[1].val.int_val = 100;

    udata_pos = 0;

    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_msg_set_item(entry, 2));
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_dev_send_msg(0x1234));
}

void test_build_snmp_getpdu(void)
{
    struct hh_oid_entry entry[2];
    entry[0].index = 0;
    entry[0].oid_name = HH_OID_ION;
    entry[0].oid_type = HH_OID_INTEGER;
    entry[0].val.int_val = 1;

    entry[1].index = 0;
    entry[1].oid_name = HH_OID_ION_ELEC;
    entry[1].oid_type = HH_OID_INTEGER;
    entry[1].val.int_val = 100;

    udata_pos = 0;

    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_msg_get_item(entry, 2));
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_dev_send_msg(0x1234));
}


void test_gateway_query_datail_msg(void)
{
    hh_usart_reg_write_func(mock_usart_send);
    hh_msg_gateway_query_detail();
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_dev_send_msg(0x1234));
    TEST_ASSERT_EQUAL(21, udata[11]);
    TEST_ASSERT_EQUAL(0, memcmp("Gateway,Query,Detail;", udata + 12, 21));
}

void test_gateway_query_devlist_msg(void)
{
    hh_usart_reg_write_func(mock_usart_send);
    hh_msg_gateway_query_devlist();
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_dev_send_msg(0x1234));
    TEST_ASSERT_EQUAL(22, udata[11]);
    TEST_ASSERT_EQUAL(0, memcmp("Gateway,Query,DevList;", udata + 12, 22));
}

void test_gateway_query_taglist_msg(void)
{
    hh_usart_reg_write_func(mock_usart_send);
    hh_msg_gateway_query_taglist();
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_dev_send_msg(0x1234));
    TEST_ASSERT_EQUAL(22, udata[11]);
    TEST_ASSERT_EQUAL(0, memcmp("Gateway,Query,TagList;", udata + 12, 22));
}

void test_parse_gateway_details_msg(void)
{
    int32_t i = 0;
    enum hh_msg_type t;
    uint32_t len = 0;
    uint8_t *data;
    uint8_t sim_data[64] = {
        0xF0, 0xA5, 0x00, 0x56, 0x00, 0x01, 0x01, 0x35,
        0x41, 0x73, 0x58, 0x31, 0x47, 0x61, 0x74, 0x65, // Gate
        0x77, 0x61, 0x79, 0x2C, 0x52, 0x65, 0x73, 0x70, // way,Resp
        0x2C, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x2C, // ,Detail,
        0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x47, 0x61, // SwitchGa
        0x74, 0x65, 0x57, 0x61, 0x79, 0x2C, 0x4B, 0x4A, // teWay,KJ
        0x44, 0x53, 0x77, 0x69, 0x74, 0x63, 0x68, 0x31, // DSwitch1
        0x57, 0x61, 0x79, 0x2C, 0x00, 0x00, 0xC0, 0x33  // Way,
	};
    for (i = 0; i < 64; i++) {
		t = hh_usart_read(sim_data[i]);
		if (i < 63) {
			TEST_ASSERT_EQUAL(HH_MSG_DATA, t);
		} else {
			TEST_ASSERT_EQUAL(HH_MSG_GATEWAY, t);
		}
	}
    hh_get_gateway_info(&data, &len);
    TEST_ASSERT_EQUAL(49, len);
    TEST_ASSERT_EQUAL(0, memcmp("Gateway,Resp,Detail,SwitchGateWay,KJDSwitch1Way,", data, len));
}

void test_parse_gateway_devList_msg(void)
{
    int32_t i = 0;
    enum hh_msg_type t;
    uint32_t len = 0;
    uint8_t *data;
    uint8_t sim_data[64] = {
        0xF0, 0xA5, 0x00, 0x08, 0x00, 0x01, 0x01, 0x27,
        0x41, 0x73, 0x58, 0x23, 0x47, 0x61, 0x74, 0x65, // Gate
        0x77, 0x61, 0x79, 0x2C, 0x52, 0x65, 0x73, 0x70, // way,Resp
        0x2C, 0x44, 0x65, 0x76, 0x4C, 0x69, 0x73, 0x74, // ,DevList
        0x2C, 0x31, 0x2C, 0x53, 0x77, 0x69, 0x74, 0x63, // ,1,Switc
        0x68, 0x31, 0x2C, 0x33, 0x35, 0x2C, 0x00, 0x00, // h1,35,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0x13
	};
    for (i = 0; i < 64; i++) {
		t = hh_usart_read(sim_data[i]);
		if (i < 63) {
			TEST_ASSERT_EQUAL(HH_MSG_DATA, t);
		} else {
			TEST_ASSERT_EQUAL(HH_MSG_GATEWAY, t);
		}
	}
    hh_get_gateway_info(&data, &len);
    TEST_ASSERT_EQUAL(35, len);
    TEST_ASSERT_EQUAL(0, memcmp("Gateway,Resp,DevList,1,Switch1,35,", data, len));
}

void test_parse_gateway_tagList_msg(void)
{
    int32_t i = 0;
    enum hh_msg_type t;
    uint32_t len = 0;
    uint8_t *data;
    uint8_t sim_data[192] = {
        0xF0, 0xA5, 0x00, 0x5C, 0x00, 0x03, 0x01, 0x36,
        0x41, 0x73, 0x58, 0x32, 0x47, 0x61, 0x74, 0x65, // Gate
        0x77, 0x61, 0x79, 0x2C, 0x52, 0x65, 0x73, 0x70, // way,Resp
        0x2C, 0x54, 0x61, 0x67, 0x4C, 0x69, 0x73, 0x74, // ,TagList
        0x2C, 0x31, 0x2C, 0x31, 0x2E, 0x33, 0x2E, 0x36, // ,1,1.3.6
        0x2E, 0x31, 0x2E, 0x34, 0x2E, 0x31, 0x2E, 0x34, // .1.4.1.4
        0x31, 0x34, 0x36, 0x37, 0x2E, 0x31, 0x2E, 0x36, // 1467.1.6
        0x30, 0x31, 0x2E, 0x31, 0x2E, 0x30, 0x32, 0xCA, // 01.1.0
        0xF0, 0xA5, 0x00, 0x5C, 0x00, 0x03, 0x02, 0x36,
        0x41, 0x73, 0x58, 0x32, 0x2C, 0x32, 0x2C, 0x31, // ,2,1
        0x2C, 0x6F, 0x6E, 0x4F, 0x66, 0x66, 0x31, 0x2C, // ,onOff1,
        0x6F, 0x6E, 0x4F, 0x66, 0x66, 0x31, 0x2C, 0x31, // onOff1,1
        0x2C, 0x31, 0x2E, 0x33, 0x2E, 0x36, 0x2E, 0x31, // ,1.3.6.1
        0x2E, 0x34, 0x2E, 0x31, 0x2E, 0x34, 0x31, 0x34, // .4.1.414
        0x36, 0x37, 0x2E, 0x31, 0x2E, 0x36, 0x30, 0x31, // 67.1.601
        0x2E, 0x32, 0x2E, 0x30, 0x2C, 0x32, 0xE3, 0x98, // .2.0,2
        0xF0, 0xA5, 0x00, 0x5C, 0x00, 0x03, 0x03, 0x22,
        0x41, 0x73, 0x58, 0x1E, 0x2C, 0x30, 0x2C, 0x6F, // ,0,o
        0x6E, 0x4F, 0x66, 0x66, 0x53, 0x74, 0x61, 0x74, // nOffStat
        0x75, 0x73, 0x31, 0x2C, 0x6F, 0x6E, 0x4F, 0x66, // us1,onOf
        0x66, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x31, // fStatus1
        0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x81,
	};

        for (i = 0; i < 192; i++) {
		t = hh_usart_read(sim_data[i]);
		if (i < 191) {
			TEST_ASSERT_EQUAL(HH_MSG_DATA, t);
		} else {
			TEST_ASSERT_EQUAL(HH_MSG_GATEWAY, t);
		}
	}
    hh_get_gateway_info(&data, &len);
    TEST_ASSERT_EQUAL(130, len);
    TEST_ASSERT_EQUAL(0, memcmp("Gateway,Resp,TagList,1,1.3.6.1.4.1.41467.1.601.1.0,2,1,onOff1,onOff1,1,1.3.6.1.4.1.41467.1.601.2.0,2,0,onOffStatus1,onOffStatus1,", data, len));
}

void test_build_snmp_setpdu_raw(void)
{
    uint8_t oid[13] = {0x2b, 6, 1, 4, 1, 0x82, 0xc3, 0x7b, 1, 0x84,0x59, 1, 0};
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_msg_set_item_raw(oid, 13, 1));
    TEST_ASSERT_EQUAL(HHP_STATUS_OK, hh_dev_send_msg(0x1234));
}
